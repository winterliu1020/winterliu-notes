![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211205201211.png)

为什么做了siftDown还要判断queue[i]是否等于moved呢？因为当moved元素所在树的分支不同时，把moved元素直接放到i位置后需要判断一下，比如我要删除上面的7，那我是拿数组最后一个元素也就是8去覆盖，如果发现8移动过去后没有往下沉，那么就需要再往上比较，因为没有往下沉，只能说明当前8覆盖7之后，以8为根节点的子树满足堆的性质，但是这个8和7在不同的子树当中，8和7都只是小于他们的最上面的根节点（这里例子不恰当，明白这个意思就行。。）8覆盖7之后，8有可能是小于7的父节点的，**所以当queue[i]==moved的时候需要执行siftUp(i, moved)**，也就是再往上比较，直到moved元素放到一个正确的位置。

