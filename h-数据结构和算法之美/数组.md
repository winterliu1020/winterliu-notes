### 数组

数组：是一种**线性表**数据结构，用一组**连续**的存储空间来存储一组具有**相同类型**的数据。

首先看线性表，链表、队列、栈都是线性表结构，线性表上的数据最多只有前后两个方向。和它对立的是非线性表，比如二叉树、堆、图，这里面的数据并不是简单的前后关系。

再看连续的存储空间和相同的数据类型，就是由于这两个特点它才有**随机访问**这个绝招。但为了保持数据的连续性，导致插入、删除等操作变得很麻烦。

注意：数组是适合查找，但是说它查找的时间复杂度是 O(1) 就不太对了，就算你数组是有序排列，用二分查找也要 O(logn)，正确的说法是：根据数组下标进行随机访问的时间复杂度是 O(1)。

- 低效的插入和删除

  每次插入都需要将插入位置后面的所有数据往后移动，但是假如这个数组只是用来存储一块数据，它们前后直接并没有什么关系，那么我们可以将插入位置的数据放到最后一个位置，再把插入的数据放到插入位置即可。

  删除也是这个道理，如果每次删除都去移动，是低效的，但是如果很多次删除连在一起，我们可以在每次删除的时候进行虚假删除，记录下每次删除的数据，在最后集中删除，这样就只需要将所有数据移动一次就行了。JVM 的标记清除垃圾回收算法就是这个原理。

- 警惕数组的越界访问问题

  在 C 语言中，并没有决定当数组越界之后编译器应该怎么做，因为访问数组的本质就是访问一段连续的内存，只要数组通过偏移得到的访问地址是可用的，程序就不会报错。

  ```c
  int main(int argc, char* argv[]){ 
  		int i = 0; int arr[3] = {0}; 
    	for(; i<=3; i++){ 
      	arr[i] = 0; 
     		printf("hello world\n"); 
    	} 
    	return 0;
  }
  ```

  其实更为细节的是，应该去了解在函数调用的时候会用到**栈**，在这里 main 函数会依次往栈中压入 i、arr[2]、arr[1]、arr[0]，由于栈是向下增长的，所以当访问 a[3] 的时候其实访问的是变量 i ，而且 i 变量的地址是属于当前进程的，所以操作系统不会终止进程。这段代码会无限打印 hello world。

  但 Java 在数组越界会：java.lang.ArrayIndexOutOfBoundsException。

- 容器是否能替代数组

  比如 ArrayList，它将数组的很多操作封装起来，且支持动态扩容，每次不够时会扩容至 1.5 倍，但是需要注意每次扩容涉及到空间申请、数据迁移，要花费比较多的时间，所以尽量在创建 ArrayList 的时候就指定大小。