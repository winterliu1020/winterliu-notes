![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20201006221250.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20201006221316.png)

这里的Car.class其实是在硬盘上的，然后通过ClassLoader它就被加载到JVM中了，也就是内存中，car1、car2、car3是Car的三个实例，它们一模一样，是因为它们来自于同一个模板，这个模板存在方法区（方法区其实就是模板工厂！！！），而方法区则存储的是每一个类的结构信息，包含这个类有几个构造方法、有几个字段、方法。

方法区是JVM中的规范，但是规范的具体实现JVM是不管的，所以在Java1.7中叫永久代，1.8中叫元空间。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20201006222512.png)

相关内容：

### Java hotSpot虚拟机中class对象是在方法区还是堆区？

class对象肯定是在堆区，而类的元数据（元数据并不是类的class对象，class对象是类加载的最终产品，类的元数据指的是类的方法代码，变量名，方法名，访问权限，返回值，这些东西的字节码会放在方法区）才放在方法区。

**看上面那张JVM和.class文件的交互图，ClassLoader在类加载时将.class文件加载到JVM内存，然后把里面的类型信息（字节码）放到方法区，并构造一个该类的Class对象（作为这些类信息数据的访问接口）放在堆。**

方法区只是JVM的一个概念，它只是一个逻辑上的存储区域，不同JVM实现不同，hotspot通过永久代来实现方法区，不过1.8之后改成元空间了，这样能让JVM加载更多的类。

JVM实现的设计者决定类型信息的内部表现形式，比如多字节变量在class文件中是以big-endian存储的，但是在加载到方法区后，其存放形式则由jvm根据不同平台来具体定义。

jvm在运行的时候要大量使用存储在方法区中的类型信息，那么jvm如何更高效的表示类型信息呢？jvm设计者既要尽可能的提高应用的运行效率，也要考虑空间问题。

方法区是被所有线程共享的，要考虑线程安全问题，比如两个线程都在试图找Java的类，在Java类还没有被加载时，只应该有一个线程去加载，而另一个线程等待。

方法区大小不必固定，jvm可以根据应用动态调整，方法区也不必连续。方法区可以在堆（甚至是虚拟机自己的堆）中分配。

类的信息：

1. 这个类的完整有效名
2. 这个类的直接父类的完整有效名（除了interface，Object）
3. 这个类的修饰符public，abstract，final的某个子集
4. 这个类的直接接口的一个有序列表
5. 除了上面这四个基本信息，jvm还要为每个类保存类的常量池，域信息，方法，除了常量外的所有静态变量

#### 常量池：

jvm给每一个已加载的类都维护一个常量池，包括：

1. 实际的常量，也就是字面量（string，integer，和floating point常量）
2. 符号引用
   - 类和接口的全限定名
   - 字段名称和描述符
   - 方法名称和描述符

池中的数据项和数据项一样，也是用索引访问。因为常量池存储了一个类所使用到的所有类型、域和方法的符号引用，所以在Java程序的动态链接中起了核心作用。

> 符号引用：字符串，能根据这个字符串定位到指定的数据，比如.class文件中java/lang/StringBuilder
>
> 直接引用：内存地址
>
> 理解：JVM和class文件都有属于自己的数据结构，当class文件被加载到jvm里面时候，jvm会根据class文件的数据结构规则，拆分读取class文件，把对应的数据放入到jvm中：加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中。
>
> 类加载之后，常量池的内容会进入运行时常量池，这时候里面的数据也许还保持着符号引用。（因为解析的时机由jvm自己设定）
>
> 调用函数时，符号引用怎么转成直接引用：如果在虚拟机栈的 栈帧中，我准备调用 main() 函数，那么会通过栈帧中持有的动态连接，找到运行时常量池， 然后找到main函数的常量 比如 #2 ，如果这个常量没有被解析过，那么就通过这个常量进行解析过程， 其中包括，通过常量 找到 类名 和 nameAndType，通过 nameAndType 找到方法名和返回值。 这时候 我手里有 类名/方法名/方法返回值，下一步，我通过类名和方法名，通过JVM记录的方法列表，找到对应的方法体。 而这个方法体实际上是一段内存地址，那么这时候我就把这段内存地址复制给 #2，并且给 #2设定一个已经解析的 flag。 这样就完成了 符号引用到直接引用的过程。

#### 域信息（也就是字段）

jvm必须在方法区中保存所有域的相关信息（域名，域类型，域修饰符）以及域的声明顺序。

#### 方法信息

方法名、方法返回值、方法的修饰符，方法的参数的数量和类型

还有：异常表、常量（被声明为final的类变量），常量的处理方法不太一样，每个常量都会在常量池中有一个拷贝。non-final类变量是被存储在声明它的类信息中的，而final类被存储在所有使用它的类信息内。

#### 对类加载器的引用

jvm必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，对于用户类加载器加载的类，jvm会把这个类的类加载器的一个引用作为类型信息的一部分保存在方法区。因为jvm在**动态链接**的时候需要这个信息，**当解析一个类到另一个类的引用的时候**，jvm需要保证这两个类的类加载器是相同的。**这对jvm区分名字空间的方式是至关重要的**。

#### 对Class类的引用

jvm为每个加载的类型（包括类和接口）都创建一个java.lang.Class的实例，jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来。

可以通过Class.forName("java.lang.Object")得到与java.lang.Object对应的类对象，可以通过这个函数得到任何包中任何已经加载的类引用，只要这个类能够被加载到当前的名字空间。但是如果jvm不能把类加载到当前的名字空间，就会抛出ClassNotFoundException。

#### 方法表

为了提高访问效率，必须仔细设计存储在方法区中的数据信息结构。除了上面讨论的结构外，jvm实现者还可以添加一些其他的数据结构，比如方法表。jvm对每个加载的非虚拟类的类型信息都添加一个方法表，**方法表是一组对类实例方法的直接引用**（包括从父类继承的方法）。这样jvm可以通过方法表快速激活实例方法。

> 这里的方法表与C++中的虚拟函数表一样，但java方法全都 是virtual的，自然也不用虚拟二字了。正像java宣称没有 指针了，其实java里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的,个人认为java的设计者 始终是把安全放在效率之上的，所有java才更适合于网络开发

### jvm如何使用方法区中的信息

> 为了显示jvm如何使用方法区中的信息，我们据一个例子，我们 
> 看下面这个类： 
> class Lava { 
> private int speed = 5; // 5 kilometers per hour 
> void flow() { 
> } 
> }
>
> class Volcano { 
> public static void main(String[] args) { 
> Lava lava = new Lava(); 
> lava.flow(); 
> } 
> } 
> 下面我们描述一下main()方法的第一条指令的字节码是如何被执行的。不同的jvm实现的差别很大，这里只是其中之一。
>
> 为了运行这个程序，你以某种方式把“Volcano”传给了jvm。有了这个名字，jvm找到了这个类文件(Volcano.class)并读入，它从类文件提取了类型信息并放在了方法区中，通过解析存在方法区中的字节码，jvm激活了main()方法，在执行时，jvm保持了一个指向当前类(Volcano)常量池的指针。
>
> 注意jvm在还没有加载Lava类的时候就已经开始执行了。正像大多数的jvm一样，不会等所有类都加载了以后才开始执行，它只会在需要的时候才加载。
>
> main()的第一条指令告知jvm为列在常量池第一项的类分配足够的内存。jvm使用指向Volcano常量池的指针找到第一项，发现是一个对Lava类的符号引用，然后它就检查方法区看lava是否已经被加载了。
>
> 这个符号引用仅仅是类lava的完整有效名”lava“。这里我们看到为了jvm能尽快从一个名称找到一个类，一个良好的数据结构是多么重要。这里jvm的实现者可以采用各种方法，如hash表，查找树等等。同样的算法可以用于Class类的forName()的实现。
> 当jvm发现还没有加载过一个称为”Lava”的类，它就开始查找并加载类文件”Lava.class”。它从类文件中抽取类型信息并放在了方法区中。
>
> jvm于是以一个直接指向方法区lava类的指针替换了常量池第一项的符号引用。以后就可以用这个指针快速的找到lava类了。而这个替换过程称为常量池解析(constant pool resolution)。在这里我们替换的是一个native指针。
>
> jvm终于开始为新的lava对象分配空间了。这次，jvm仍然需要方法区中的信息。它使用指向lava数据的指针(刚才指向volcano常量池第一项的指针)找到一个lava对象究竟需要多少空间。
>
> jvm总能够从存储在方法区中的类型信息知道某类型对象需要的空间。但一个对象在不同的jvm中可能需要不同的空间，而且它的空间分布也是不同的。(译者：这与在C++中，不同的编译器也有不同的对象模型是一个道理)
>
> 一旦jvm知道了一个Lava对象所要的空间，它就在堆上分配这个空间并把这个实例的变量speed初始化为缺省值0。假如lava的父对象也有实例变量，则也会初始化。
> 当把新生成的lava对象的引用压到栈中，第一条指令也结束了。下面的指令利用这个引用激活java代码把speed变量设为初始值 5。另外一条指令会用这个引用激活Lava对象的flow()方法。

[参考来源](https://my.oschina.net/u/3628059/blog/1557569#:~:text=Class%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%AD%98%E6%94%BE%E5%9C%A8,%E6%98%AF%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E3%80%82&text=%E5%9C%A8%E4%B8%80%E4%B8%AAJVM%E5%AE%9E%E4%BE%8B%E7%9A%84,%E7%9A%84%E5%86%85%E5%AD%98%E9%80%BB%E8%BE%91%E5%8C%BA%E4%B8%AD%E3%80%82)