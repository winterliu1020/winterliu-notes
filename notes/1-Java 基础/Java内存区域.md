### 前言

Java虚拟机在执行Java程序的过程中会把它管理的内存区域划分成若干个不同的数据区域。有的区域属于所有线程共享的(这些区域随着虚拟机进程的启动而存在)、有些区域属于线程隔离的(这些区域则依赖于用户线程的启动和结束)。划分成以下区域：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/JVM/JVM内存数据区.png)  

### 1. 程序计数器
程序计数器是一个很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。  

每条线程都需要一个独立的程序计数器，各个线程之间程序计数器互不影响，独立存储，程序计数器这片小内存叫做“线程私有”的内存。  

如果线程正在执行的是一个Java方法，那么这个程序计数器记录的就是正在执行的虚拟机字节码指令的地址。  

### 2. Java虚拟机栈

这片区域也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型(也就是说虚拟机栈是对于Java方法而言，而方法区则存储的是一些Class基本信息，即针对的是类)，每个方法执行时都会创建一个栈帧用于存储局部变量、操作数栈、动态链表、方法出口等信息，每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  

Java虚拟机栈中包含了局部变量表，而局部变量表中存的是：编译器可知的基本数据类型、对象引用类型和returnAddress类型。  

局部变量表所需的内存空间在编译期间就可以完成分配，当进入一个方法时，这个方法需要多少局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。  

### 3. 本地方法栈
本地方法栈和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。  
### 4.Java堆
Java堆是Java虚拟机管理的最大的一片内存区域。被所有线程共享，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象。所有的对象实例和数组都要在堆上分配。  

Java堆是垃圾收集器的主要区域。  

### 5. 方法区
方法区也是各个线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。

### 6.运行时常量池
它是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。  

--------
以下探究HotSpot虚拟机在Java堆中对象分配、布局和访问的过程：
### 1. 对象的创建(例如克隆、反序列化)
从语言层面，创建对象仅仅是一个new关键字而已，而从Java虚拟机来看，创建一个对象(这里仅仅指普通对象，不包括数组和Class对象)的过程如下：  
1. 虚拟机遇到一条new指令时，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则必须先执行相应类的加载过程。  
2. 类加载检查通过后，然后虚拟机将为新生对象分配内存。对象所需要的内存大小在类加载完后便可以完全确定。为对象分配内存其实就是将一块确定大小的内存从Java堆中划分出来。  
3. 根据Java堆是否规整，在分配内存时是会采用不同的策略的，一般采用：指针碰撞(Bump the Pointer)、空闲列表(Free List)。而Java堆是否规整又是由所采用的垃圾收集器是否带有压缩整理功能决定的。
4. 需要注意的是，由于Java对象的创建是非常常见的，比如仅仅是修改一个指针所指向的位置，在并发情况下也可能存在线程安全问题，可能出现正在给对象A分配内存，内存已经在Java堆中划分出来了，但是还没来得及将指针指向这块内存，另一个线程中的对象B又同时使用了原来这个指针来分配内存。以上这个过程是存在问题的，解决办法有两种，一是对分配内存的动作进行同步处理，保证这个操作的原子性。另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，那个线程需要分配内存，就在哪个线程的TLAB上分配，只有当TLAB使用完了并分配新的TLAB时，才需要**同步锁定**。  
5. 内存分配完成后，虚拟机会将分配到的内存空间都初始化为零值(不包括对象头)。然后虚拟机要对对象进行一些设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。  

到此，从虚拟机的视角，一个对象已经产生了，但是从Java程序的视角来看，对象的创建才刚开始(才仅仅分配了内存、初始化了一些类数据)，<init>方法还没有执行，对象中所有的字段都还为零。执行new指令之后会接着执行<init>方法，把对象按照程序员的意向进行初始化，这样一个真正可用的对象才算真正产生出来。

### 2. 对象的内存布局
对象在内存中的布局可以分为3块区域：对象头(Head)、实例数据(Instance Data)、对齐填充(Padding)。  

对象头，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  

实例数据部分是对象真正存储的有效信息，也是程序代码中定义的各种类型的字段内容。

### 3. 对象的访问定位
建立对象是为了使用对象，而在Java程序中需要通过栈(一般指虚拟机栈)上的reference数据来操作堆上的具体对象。由于reference在Java虚拟机规范中只规定了一个指向对象的引用，并没有规定这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式要看虚拟机具体如何实现，一般有两种方式：使用句柄、直接指针。

1.使用句柄访问的话，Java堆中会 `分出一块内存当做句柄池 `，reference中存储的就是对象的句柄地址，句柄中则包含了对象实例数据与类型数据各自的具体地址信息。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/JVM/通过句柄访问对象.png)

2.使用直接指针访问的话，那Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，这里reference中存储的直接就是对象的地址。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/JVM/通过直接指针访问对象.png)  

句柄访问好处：存储稳定 (常用)     
直接指针访问好处：访问速度快