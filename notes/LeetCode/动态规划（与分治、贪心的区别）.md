## 动态规划（与分治、贪心的区别）

核心：

> Those who cannot remember the past are condemned to repeat it.

也就是说它的核心在于记录下之前求过的子问题的解。一般动态规划问题开始都是简单的用递归来做，但是简单的用递归做意味着你不会存储计算过程中求得的子问题的解，这样就导致很多小递归是重复计算了的。所以想到用一个空间（也就是一张表或者说一个二维数组）来存储利用递归计算过程中产生的子问题的解，这样当你每次调用递归函数的时候首先去看一下这个二维数组中有没有求过这个子问题，有的话就直接返回结果。

### 再说一下 DP 适用的场景：1.重叠子问题   2.最优子结构

维基百科上说 DP 在查找很多**重叠子问题**的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并保存，从简单的问题直到整个问题都被解决。记住 DP 是一种思想，递归只是一种编程技巧，DP 中用到了递归而已。

动态规划只能适用于有**最优子结构**的问题，也就是局部最优解能够决定全局最优解。其实就是说大问题可以通过分成小问题来解决。

### DP 的两种形式（UpBottom，BottomUp）

一般来说简单**递归**加上 memorization 技术就变成了**自顶向下的 DP**，然而相对于自顶向下的动态规划，因为它在递归过程中需要不断的压栈出栈，所以我们会想到用**自底向上的动态规划**，不断去填充记录结果的二维数组。其实就是逐个将小问题解决，然后在求大问题的时候因为小问题都解决了并且结果已经保存了，所以直接取就行了。这样不需要栈操作，时间消耗更少。

### DP 和分治、贪心的区别     [参考来源](https://zhuanlan.zhihu.com/p/33048876)

1.分治

一般步骤都是：分解 --> 解决 --> 合并

2.DP

描述最优解的结构 --> 递归定义最优解的值 --> 按自底向上的方式计算最优解的值 --> 由计算的结果构造一个最优解

分治：子问题独立；  DP：子问题独立且重叠

3.贪心 （注意贪心适用的场景，比如下面的 LeetCode322 题就不能用贪心来做）

一般 DP 和贪心都是用来求最优化问题，但是用 DP 就有点杀鸡用牛刀了，简单的用贪心算法就可以。贪心算法是去做选择，它只需要考虑一个选择（也就是基于贪心做出的选择）。

贪心和 DP 相同的是都适用于最优子结构，但是贪心算法中是以自顶向下的方式使用最优子结构，贪心算法会先做选择，在当时看起来是最优的选择，然后再求解一个结果子问题，而不是先求子问题的最优解，然后再做选择。而在动态规划中每一步都要做出选择，这些选择都是依赖于子问题的解，所以动态规划一般都是自底向上来解决，从解决小子问题到解决大子问题。

> **因此，贪心算法通常是自顶向下地做出贪心选择，不断地将给定的问题实例归约为更小的问题。贪心算法划分子问题的结果，通常是仅存在一个非空的子问题。**



### 动态规划的经典模型（线性模型、区间模型、背包模型）

其实简单点看线性就是用一维数组保存计算结果，区间模型就是用二维数组保存结果咯。但是一维数组也可以看成是只有一行的二维数组，所以维基百科上说在解决动态规划的时候通常用一张表格（也就是一个二维数组）来保存子问题的计算结果。这样看线性模型和区间模型就相通了。

**1.线性模型**

这里的线性指的是状态的分布是呈线性的，比如 [322题](https://leetcode.com/problems/coin-change/) 就是一个线性 DP 问题，它的状态转移方程是：F(S) = F(S - C) + 1;

```JAVA
// 方法二：用动态规划试试 大问题化解为小问题  这里用的是自顶向下
public int coinChangeHelper(int[] coins, int amount, int[] count) {
    if (amount < 0) {
        return -1;
    }
    if (amount == 0) {
        return 0;
    }
    if (count[amount - 1] != 0) return count[amount - 1]; // 如果这个问题之前计算了，直接取结果
    int min = Integer.MAX_VALUE;
    for (int coin : coins) {
        int res = coinChangeHelper(coins, amount - coin, count);
        if (res >= 0 && res < min) {
            min = 1 + res;
        }
    }
    count[amount - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
    return count[amount - 1];
}

// 方法三：自底向上动态规划
// 其实就是和自顶向下相反，也是用一个函数F(S)
public int coinChangeHelperBottomToUp(int[] coins, int amount, int[] count) {
    int max = amount + 1;
    Arrays.fill(count, max);
    count[0] = 0;

    for (int i = 1; i <= amount; i++) {
        // count[i] = min{F(i-ci);  i-ci>= 0}
        int temp = Integer.MAX_VALUE;
        for (int coin : coins) {
            if (i - coin >= 0 && count[i - coin] < temp) {
                temp = count[i - coin];
            }
        }
        // 最终的temp就记录的是min{F(i-ci)； i-ci>=0}
        if (temp != Integer.MAX_VALUE) {
            count[i] = temp + 1;
        }
    }
    // for循环之后就可以得到一个填充好的count数组，因为初始化count数组的时候我给这个数组都填充的是amount+1，因为硬币至少是一块钱的，所以这就标记了一下，如果count[amount]最后改变了，说明硬币能够换成功
    return count[amount] > amount ? -1 : count[amount];
}
```

再说一个线性模型比较经典的例子：

在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。

1~n 号小朋友，首先 Arrays.sort(T)，也就是 T[1]~T[n] 从小到大排列

这个问题也是用 DP 来做，我们可以将这个问题化简，我们总得送 i 号小朋友过河吧，那么就有两种情况，

**1.如果送 n 过河的伙伴送完 n 过河之后立马把手电筒还回去**

T1 送 Tn 过河，然后 T1 把手电筒还回去，此时还未过桥的人有 T[1...n-1]，所以花费时间（状态转移方程）：

**dp[n] = T[n] + T[1] + dp[n-1]**

**2.如果送 n 过河的伙伴送完 n 过河之后没有立马把手电筒还回去**

那总得有人把手电筒送回去吧，那就是第三者，这个第三者此时已经过桥了，而且这个第三者当时过桥的伙伴一定不是 Tn 或者 Tn 的伙伴，但是这个第三者当时不可能一个人过桥，因为得有一个人把手电筒送回过去，所以还存在第四个人，也就是整个过程涉及到四个人。则这种情况下的最佳策略就是：

T1（第三者）、T2（第三者当时过河的伙伴）过河，然后 T2 留在那边，T1 回来还手电筒，花费 T1 + T2，然后 Tn 和 Tn-1 一起过河，但是让 T2 拿手电筒回来，此时剩下的人就是 T1~Tn-2，花费时间是：**dp[n] = dp[n-2] + 2*T2 + T1 + Tn**

这一点还需要仔细考虑：为什么是T0,T1,T_{n-2}来陪伴T_{n-1}玩这场游戏? 因为如果不是的话，则通过简单替换就可以证明计划不是最优的（算法导论中称之为copy-paste论证）

**所以最终递推公式是：**

```mathematica
假设 T[0,..,n-1]升序排序，则有
dp(n) = min{dp(n-1), dp(n-2)+2*T1} + T[0]+T[n-1], n>=2, dp(0)=T[0], dp(1)=T1
```

参考：阿里面试题-小朋友过河](https://yfsyfs.gitee.io/2019/07/04/%E9%98%BF%E9%87%8C%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4%E8%BF%87%E6%A1%A5%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/) （这里面还有扩展，如果每次允许3个人..4个人..k个人结果又是怎样）

---

还有另外一个人用堆来做：[用堆来做小朋友过河问题](https://www.cnblogs.com/guguli/p/4357922.html)

> 计算的这道题方法其实类似于动态规划，关键在于寻找最优子结构
>
> 1）问题的最优子结构是这样推出的
>
> 　　1.每一个人都得过河
>
> 　　2.由1可以知道cost最大的一个也必须过河
>
> 　　3.由2可知必然有一次过河的代价为cost（max）
>
> 　　4.由3可知，在将cost最大的人送过河的运输中最优的方案是将cost第二大的人也同时过河
>
> 　　因此问题可以转化为如何将cost第一大和第二大的两个人同时送过河
>
> 2）最优化问题的解法在于首先将cost最小的两个人先送过河然后选择其一送回手电筒（无论哪个人都一样），然后再使cost最大和第二大的两个人同时过河，再另上一次剩在另一　　岸的cost最小或者次小的人送回手电筒
>
> 　　因此每次将一对人送过河的cost=iMax1st+(iMin2nd+2*iMin1st)
>
> 3）按总人数的奇数偶数可以将整个问题循环之后分支为两个子问题（显而易见，不多赘述）
>
> 4)利用大根堆和小根堆使遍历的时间复杂度从n降低至logn

---

还有人说：要么是最快者将最慢的两个人送过桥，要么是最快的两个将最慢的两人送过桥     [能者多劳](https://blog.csdn.net/nameix/article/details/52016767)

> 因此可以得出更加细化的解决方案——要么是最快者将最慢的2个送过桥，要么是最快的2个将最慢的2个送过桥。即将过桥的人按其过桥的时间从小到大排列，设为A，B，……Y，Z。其中A和B是最快的二个，Y和Z是最慢的二个。那么就有二种方案：
>
> 方案一 最快者将最慢的2个送过桥
>
> 第一步：A和Z过桥，花费Z分钟。
>
> 第二步：A回来，花费A分钟。
>
> 第三步：A和Y过桥，花费Y分钟。
>
> 第四步：A回来，花费A分钟。
>
> 这四步后总人数就减小2个，花费时间为A + A + Y + Z分钟。
>
> 方案二 最快的2个将最慢的2个送过桥
>
> 第一步：A和B过桥，花费B分钟。
>
> 第二步：A回来，花费A分钟。
>
> 第三步：Y和Z过桥，花费Z分钟。
>
> 第四步：B回来，花费B分钟。
>
> 这四步后总人数同样减小2个，花费时间为A + B + B + Z分钟。
>
> 这样，每次比较一下这二种方案就能将总人数减小2。然后我们再考虑一些边界情况：
>
> 有三个人过桥设为A，B，C（已经排好序，下同）。应该花费A + B + C分钟。
>
> 有二个人过桥设为A，B。那么肯定是花费B分钟。
>
> 有一个人过桥设为A。肯定花费A分钟。
>
> 
>
> 所以 只需要比较 (B+B)>?(A+Y)
>
> int m=((2B)>(A+Y))?2B:(A+Y)
>
> 总时间： B+A+Z+m



