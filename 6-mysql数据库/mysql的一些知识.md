5.5之前，MySQL的默认存储引擎是MyISAM，这个引擎支持压缩、全文索引，但是不支持事务，所以崩溃的时候无法安全恢复。

所以在5.5之后，默认引擎换成了InnoDB(事务性数据库存储引擎)。

### MyISAM 和 InnoDB对比

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227172038.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227172902.png)

可以看到InnoDB确实牛逼，保证了事务的持久性（通过重做日志）、原子性（通过回滚日志）、隔离性（通过锁机制），然后一致性才能得到保障。

而MyISAM就有点拉垮了，事务不支持，当数据库崩溃了还不能恢复到崩溃前的状态。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227173813.png)



### ACID

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227174253.png)

关系型数据库都有ACID属性，其实这四者之间也有联系。就像上面说的：保证了原子性、持久性、隔离性，才达到了一执性。

### 再来详细看看事务

事务其实有点像多线程了。。。多个线程对共享数据进行修改访问，就存在并发问题，那么多个事务同时对同一片数据进行修改访问，也就会存在并发问题。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227175019.png)

上面四种就是并发事务可能发生的问题：

脏读（一个事务修改、一个事务立马去读）：一个事务修改了数据，但是还没放到数据库，另一个事务就去读了这个还没有提交到数据库中的数据，这就叫脏读。因为这些数据还没有提交到数据库，就有一点类似于多线程中这些数据还在线程的本地内存，还没有更新到主内存。。所以你依据“脏数据”做的操作可能是不正确的。

丢失修改（一个事务修改、另一个事务立马对同一片数据修改）：相当于前一个事务产生的修改丢失了。

不可重复读（第一个事务第一次读，第二个事务修改，第一个事务再读）：造成第一个事务在同一个事务中两次读数据不一样的情况。

幻读（第一个事务第一次读，第二个事务插入或者删除一些记录，第一个事务再读）：同一个事务两次读查到的记录可能不存在了或者查到了更多的记录。

### 所以需要解决并发事务带来的问题

事务隔离级别：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227180331.png)

### Mysql的隔离级别

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211227180924.png)

### 数据库性能变差的原因有哪些呢？？

我能想到的，因为都是把数据加载到内存，然后在内存执行相关的操作，如果你每一条记录过大，那加载到内存的记录条数就变少了，需要多次磁盘IO。。消耗时间

比如还有索引如果太多了，反而不好，因为mysql需要根据多个索引选出一个最佳的索引，索引过多会增加选择时间。

当然还有一些不规范的sql语句，比如直接用select * from xxx;这样一个是需要把所有数据放到内存，增加磁盘io，另外一个是如果表结构发生变化，那你查询出来的列也就变化了。。