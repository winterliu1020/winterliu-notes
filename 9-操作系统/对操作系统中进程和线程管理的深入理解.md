### 先看看操作系统中用户态和内核态

对CPU的所有指令进行了等级划分，也就是划分成不同的权限，内核态对应最高指令权限，可以执行所有CPU指令，而用户态对应最低级的权限，只能执行少部分的CPU指令。。。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211216175747.png)

所以说区分用户态和内核态本质上是一个安全问题，给指令划分权限。

我们说系统中断会导致CPU从用户态切换到内核态，那切换的本质是什么呢？其实很简单，切换就是从用户线程切换到内核线程，比如你程序中要进行io，那你肯定需要用到最高级别的CPU指令，所以必须切换到内核态去执行这行代码，其表现形式就是：**代码从应用程序所在的用户线程切换到内核中的内核线程去执行。**

那什么是用户线程，什么是内核线程，内核线程在哪里，为什么它可以执行ring0级别的CPU指令。。。

CPU指令的权限更高，也说明这些指令能够调用的内存资源、硬件资源更多。。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220105320.png)

可以看到用户态只能访问用户程序数据，执行用户线程，那么内核线程的运行、还有对硬件资源的访问都必须在内核态。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220110019.png)

那我们再看看什么时候会发生用户态切换到内核态呢？当然是有些行为必须由内核态来完成，比如需要系统调用。或者发生了中断、异常，都会由用户态转到内核态。

什么是系统调用：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220111029.png)

### 你有没有想过什么是进程，进程在内核中是什么东西？

其实一个进程就是一段记录资源和状态的task_struct结构体，这个结构体就叫PCB，进程控制块，然后每个进程都是一个这样的结构体，其实本质就是用这个结构体记录一些数据，这些数据用来描述有这么个进程，比如标识符、状态（进程的状态：挂起、阻塞、运行）、这个进程的上下文信息。。。而在操作系统上运行的所有进程都是这么些结构体，也就是一堆记录数据而已，本质上还得由操作系统的进程管理模块来对这些数据进行管理。而这些数据本质上是记录的这个进程所拥有的物理资源或者自身的状态信息。

而进程的这个结构体数据也是在3-4G这个部分的内存地址，也就是内核态，所以用户态程序是无法访问这个结构体的，如果要访问必须切换到内核态。那你想想为什么不能访问这个PCB呢？比如有一个恶意程序可以访问PCB的数据，那我直接把这个PCB的优先级标为最高。。。这很危险。。所以内核态的数据必须由内核线程去管理。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220113617.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220113422.png)

### 再想想进程之间的通信方式？

因为每个进程在用户态都有自己单独的地址空间，所以两个进程想要通信则必须通过内核态来完成，进程1把数据拷贝到内核态中的缓冲区，然后进程2再把内核态中的数据复制到自己进程中。

<img src="https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20220102152107.png" style="zoom:50%;" />

这是一个宽泛的进程间通信模型。具体有：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20220102152714.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20220102153254.png)

当然还有消息队列、共享内存、套接字方式用于进程间通信。

其实这些本质都是用的进程间通信模型，也就是用到内核态内存，无非是只简单开辟一块内存给他们用，还是开辟内存并且管理这片内存，比如消息队列就会存储一个进程发过来的消息，但是另外一个进程不需要一直在等待。由内核去管理这些消息在两个进程之间的通信。

### 那什么是线程呢？

有没有想过**线程为什么能共享堆内存空间呢**？首先对于资源分配来说，进程是资源分配的最小单位，那操作系统把资源分配给了某一个进程，然后这个进程下开辟的所有线程公用这些资源，首先我们知道进程只是一个task_struct结构体，也就是只记录一些数据；那再说会线程为什么能共享内存空间？共享的本质是什么？它怎么共享？我们知道进程也只是用一个结构体来记录一些数据来说明自己占有的资源，那线程是不是也是用一个结构体记录自己的资源呢？

是的，线程在内核中和进程一样，也是一个task_struct结构体，记录当前线程的标识符、状态。。只不过有一些名字不一样，线程中叫PC程序计数器，所以总的来说：线程在new出来之后就是把进程的PCB复制一份给自己，然后加上PCB中没有的PC程序计数器，堆栈啥的。。这个线程的结构体就叫TCB，线程控制块。

线程本质上就是多了个任务列表，就是栈帧。

那为什么多个线程能共享堆内存空间？其实就是每个线程都是把PCB信息复制到自己的TCB来，那这些线程当然操作的都是同一块内存空间了。

### 内核线程

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220115800.png)

### 用户线程

Linux中默认是一个用户线程对应一个内核线程，用户线程会绑定到对应的内核线程上。在JVM中创建一个Thread对象，会创建一个用户态线程和一个内核态线程，然后把用户态线程绑定到该内核线程，低权限代码就在用户态执行，高权限代码就需要切换到内核态中的内核线程执行。

从用户态切换到内核态是由内核线程来完成的，当需要执行高权限指令时，就使用内核线程接受系统内核的调度，然后由内核线程来执行这部分高权限指令。

### 用户态线程转换成内核态线程

其实就和两个线程的之间的转换是一样的。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220152841.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220153041.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220153647.png)

参考：https://juejin.cn/post/6920621924791894023

### 创建进程为什么比创建线程开销要大？

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211220155116.png)

但是各个进程的资源是相互隔离的。

现代CPU调度的都是线程，进程只是资源分配的基本单位。

### 进程的几种状态

创建、就绪、运行、阻塞、结束

### 线程间同步方式

互斥量Mutex，也就是说这个互斥量只有一个，而只有拿到互斥量的线程才能访问共享资源（Synchronized、Lock）、信号量（控制同一时刻允许访问共享资源的线程数，类似于JUC下的Semaphore）、当然还有事件，通过事件通知的方式保证线程间同步

### 进程调度算法

先来先服务、短作业优先、时间片轮转调度、优先级调度、多级反馈队列调度算法；

其中多级反馈调度算法相对最好，它设计了多个队列，当一个进程刚来的时候会先放到第一个队列，第一个队列优先级最高，但是越后面的队列中分配的时间片越长，只有当第一个队列中没东西了，才会执行第二个队列。。。

如果一个进程在第一个队列中，在一个时间片后还没执行完，就会放到第二个队列的队尾。

### 死锁产生的条件

互斥、占有并等待、非抢占、循环等待。
