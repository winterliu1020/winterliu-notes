Java中加锁一般有两种方式：synchronized关键字、Lock接口的实现类。synchronized就像自动挡，可以满足日常同步的需求，而如果要进行一些特定的操作，就需要用手动挡，也就是各种Lock的实现类。

### synchronized锁升级（四种锁状态）：无锁->偏向锁->轻量级锁（就是一种自旋锁）->重量级锁

上面说synchronized是自动挡，其实就是说JVM会负责在不同的速度下帮你调节档位，也就是看线程竞争情况帮你对synchronized锁进行升级，注意：synchronized锁只能按照偏向锁->轻量级锁->重量级锁进行升级（也叫锁膨胀），不能降级。

具体来说这个加油换挡的过程：

**偏向锁：**

初次执行synchronized代码块的时候，锁对象变成**偏向锁**（通过CAS修改对象头里的锁标志位），意思是：“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块的时候，线程会判断持有锁的线程是否是自己（持有锁的线程ID在对象头里面），如果是则正常往下执行。由于之前没有释放锁，这里就不再需要重新加锁。（如果自始至终使用锁的线程只有一个，很明显偏向锁就不需要重复进行CAS操作来加锁，只需要看一下对象头中的线程ID即可，性能极高）

注意：当一个线程访问同步代码块并获取锁时，会在Mark Word里面存储锁偏向的线程ID。**在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁**。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS操作即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

**轻量级锁**：

一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。在轻量级锁状态下进行锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能被成功获取（其实就是通过CAS修改对象头里的锁标志位）。

如果一个线程已经拿到了锁，其它线程只能进行自旋（也就是原地空耗CPU，这种现象叫忙等），当竞争比较小的时候会采用轻量级锁，也就是允许短时间的忙等，这是一种折中的想法，换取线程在用户态和内核态之间切换的开销。

**重量级锁：**

当自旋操作超过10次，说明竞争比较激烈，那么会升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID），如果后续线程尝试获取锁，发现占用的锁是重量级锁，则直接将自己挂起。



偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。



[csdn](https://blog.csdn.net/zmh458/article/details/93053867)

[美团博客](https://tech.meituan.com/2018/11/15/java-lock.html)

[知乎](https://zhuanlan.zhihu.com/p/71156910)