synchronized是Java语言内置的关键字，Lock是一个接口，接口的实现类在代码层面实现了锁的功能。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/concurrent/20210422102253.png)

可重入、读锁、写锁

ReentranReadWriteLock实现了ReadWriteLock接口，同时它还有两个内部静态类ReadLock和WriteLock。

一、悲观锁与乐观锁

这并不是特指Java中Lock接口的实现类的哪个锁，乐观、悲观指的是在并发情况下的两种**不同策略**。

悲观锁：每次拿数据的时候都认为别人会修改，所以它在拿数据的时候会上锁，这样别人拿数据就会被挡住，直到悲观锁被释放。

乐观锁：拿数据的时候认为别人不会修改，所以**不会上锁**，但是当更新数据时，则会在更新前检查在读取到更新这段时间别人有没有修改过这个数据，如果修改过，则重新读取，然后再次尝试更新，循环上述步骤直到更新成功。（其实CAS就是一种乐观锁）

悲观锁阻塞事务，乐观锁回滚重试。

二、乐观锁的基础-- CAS(currentValue, oldValue, newValue)

compare and swap(set)；其实就是：你要对某个值进行修改对吧，那在你改这个值的前一刻你看看这个值是不是被其它线程修改过了，没有修改过说明你可以修改，修改过了说明其它线程已经拿了这个共享值，那你肯定不能动了，所以"啥也不干，循环重试"

> 我的理解：CAS中，每个线程如果想更新共享资源值，首先都会去读这个共享资源值（这其实相当于每个线程都挂了一个号，这个号没有顺序，只是说明你拥有了修改共享资源值的权利，然后挂了号的这些线程开始**抢着去修改**，注意下面是一个**原子操作**：（要修改之前会拿着挂的号也就是oldValue去和当前的currentValue进行比较，如果两者相同，说明这个共享资源值没有被其它线程修改过，那么可以更新为新的值，但是如果两者不相同，说明这个值被其它线程改过了，也就是说当前这个号无效了，**那么会重新读取 相当于重新挂号**，然后再次尝试更新，一种循环。。。）

1. 比较：读取到了一个值A，在将其更新为B之前，检查原值是否为A（未被其它线程改动）
2. 设置：如果是，将A更新为B，结束，如果不是，什么都不做。

乐观锁没有加锁、解锁，所以乐观锁策略也叫无锁编程，它其实就是一个循环重试CAS算法。

三、自旋锁

Java中并没有自旋锁这个类，自旋说白了就是while(true)无限循环，虽然操作上是一样的，但是应该将自旋和while(true)分开，自旋锁特指自旋锁的自旋，synchronized中锁状态为轻量级锁时，这个轻量级锁就是一种自旋锁，当有少量线程参与竞争锁时，没有抢到锁的线程将自旋，即：不停地循环判断锁是否能够成功被获取，也就是：**不停地通过CAS算法修改对象头里的锁标志位，先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，然后线程将当前锁的持有者信息修改为自己。**

四、可重入锁（递归锁）

Java中所有现成的Lock实现类、synchronized关键字锁都是可重入锁。

五、可中断锁（可以响应中断的锁）

什么是中断？Java并没有提供任何直接中断某线程的方法，只提供了**中断机制**。

> 什么是中断机制：线程A向线程B发出“请你停止运行”的请求（B也可以自己给自己发送），但B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说：Java中断并不能直接终止线程，而是需要被中断的线程自己决定怎么处理。

synchronized是不可中断锁，也就是它不能响应中断，而Lock的实现类都是可中断锁。

```java
/* Lock接口 */
public interface Lock {

    void lock(); // 拿不到锁就一直等，拿到马上返回。

    void lockInterruptibly() throws InterruptedException; // 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。

    boolean tryLock(); // 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。

    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 同上，可以自定义等待的时间。

    void unlock();

    Condition newCondition();
}
```

六、读写锁、共享锁、互斥锁

读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排他锁）。

看下Java里的ReadWriteLock接口，它只规定了两个方法，一个返回读锁，一个返回写锁。

```java
public interface ReadWriteLock {
	Lock readLock();
	Lock writeLock();
}
```

读写锁其实做的事情是一样的，但是策略稍有不同。很多情况下，线程知道自己读取数据后，是否是为了更新它。那么何不在加锁的时候直接明确这一点呢？如果我读取值是为了更新它（SQL的for update就是这个意思），那么加锁的时候就直接加**写锁**，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅为了前端展示，那么加锁时就明确地加一个**读锁，**其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）。

虽然读写锁感觉与乐观锁有点像，但是**读写锁是悲观锁策略**。因为读写锁并没有在**更新前**判断值有没有被修改过，而是在**加锁前**决定应该用读锁还是写锁。乐观锁特指无锁编程。

七：回到乐观锁和悲观锁

观点：我们在Java里使用的各种锁，**几乎全都是悲观锁**。synchronized从偏向锁、轻量级锁到重量级锁，全是悲观锁。JDK提供的Lock实现类全是悲观锁。其实只要有“锁对象”出现，那么就一定是悲观锁。因为**乐观锁不是锁，而是一个在循环里尝试CAS的算法。**而你偏向锁、轻量级本质上确实用到了锁，所以它不是乐观锁。

那JDK并发包里到底有没有乐观锁呢？

有。java.util.concurrent.atomic包里面的**原子类**都是利用乐观锁实现的。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/concurrent/20210422115731.png)

> 为什么网上有些资料认为偏向锁、轻量级锁是乐观锁？理由是它们底层用到了CAS？或者是把“乐观/悲观”与“轻量/重量”搞混了？其实，线程在抢占这些锁的时候，确实是循环+CAS的操作，感觉好像是乐观锁。但问题的关键是，我们说一个锁是悲观锁还是乐观锁，总是应该站在应用层，看它们是如何锁住应用数据的，而不是站在底层看抢占锁的过程。如果一个线程尝试获取锁时，发现已经被占用，它是否继续读取数据，等后续要更新时再决定要不要重试？对于偏向锁、轻量级锁来说，显然答案是否定的。无论是挂起还是忙等，对应用数据的读取操作都被“挡住”了。从这个角度看，它们确实是悲观锁。

[知乎](https://zhuanlan.zhihu.com/p/71156910)