### JMM

到底什么是java内存模型？我觉得它就是一种规范，规定了线程A对共享变量的写入何时对线程B可见。内存模型本质作用就是控制线程之间的通信（再具体一点，就是控制线程A的本地内存与主内存的交互、控制线程B的本地内存和主内存的交互），解决内存可见性问题。

那再想一想为什么需要有内存模型？因为操作系统能够多线程处理，那么多线程之间如何通信就是一个问题，本质上要解决的就是多线程之间如何通信、多线程之间如何同步这两个问题，多线程通信有共享内存、线程间传递消息两种方式，Java多线程通信采用的是共享内存的方式，如果没有JMM，那单纯的多个线程共享一个内存会出现问题，所以产生了JMM，它是一个理论，并不是一个具体的东西，它规定了一个线程对共享内存的写入何时对另一个线程可见，通过JMM来解决多线程共享一个内存存在的问题。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211103112853.png)

如果是非共享变量，那么它是不受JMM控制的，因为非共享变量是线程独有的，那它当然没有内存可见性问题，当然不需要JMM去控制该非共享变量何时对另一个线程可见。

那么Java中哪些是共享变量、哪些是非共享的呢？Java中堆内存是共享的，堆内存中有实例对象、静态对象（静态对象的信息是在class文件中，class 字节码文件在方法区，但是一个class文件会被加载到一个class对象中，而这个class对象也是存放在堆中的）、数组元素（Java中的数组本质上也就是一个对象，也放在堆区）；而非共享的是栈区，栈区这里指的是Java中的虚拟机栈，Java中执行的每一个方法会以一个栈帧的形式入到虚拟机栈，而这些方法中的本地变量、方法定义参数都是在这个栈帧中的，这些都是非共享变量。

### 重排序

首先想一下Java代码到CPU指令执行，中间会发生些什么？传统步骤大概是：Java代码、class字节码、机器码、机器码翻译成具体的CPU指令。

那其实就是代码 --> CPU指令，现代编译器和CPU会对这个过程做优化，也就是编译器优化部分、处理器优化部分。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211103171105.png)

第一个编译器优化重排序，其实就是在不改变程序语义的前提下，编译器可以安排语句的执行顺序。然后语句编译成指令之后，处理器还会对这些指令进行重排序，因为处理器可以并行执行多条指令。第三个内存系统的重排序，因为有缓存的存在，所以存储和加载操作可能是乱序的。

这三个重排序都会导致多线程之间存在内存可见性问题，所以JMM：1.会禁止一些特定类型的编译器对语句的重排序 2.对于指令重排序，JMM会在某些地方插入内存屏障，来解决多线程之间的内存可见性问题。

























