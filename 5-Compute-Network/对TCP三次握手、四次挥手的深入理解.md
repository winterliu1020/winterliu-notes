三次握手的目的是确定：客户端确定自己发送的包服务器能够接收到；服务器端确定自己发送的包客户端能够接收到。

先看看TCP报文：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215170722.png)

而tcp中主要就是用ACK, SYN这两个bit：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215170853.png)



![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215172154.png)

三次握手，前两次，也就是一去、一回，只能说客户端知道自己发的消息服务器能够收到，但是只有两次握手，服务器端不知道在第二次握手时发过去的包客户端是否收到，所以必须要第三次握手，通过第二、三次握手，服务器端也知道自己发送的包客户端能够收到。

可以看到第二次握手，服务器发送的即是确认包、又是同步包，而tcp断开连接，就必须执行四次挥手，就是因为客户端和服务器端是全双工的，所以无法说在服务器端收到客户端发来的结束通话后立即也发送结束通话，因为可能服务器端还需要传一些数据给客户端，所以第二次挥手仅仅是对第一次挥手的回应，也就是说客户端已经知道它发给服务器端的结束通话信息服务器已经知道了。

第二次挥手后，然后服务器再发一些数据，然后服务器发送结束包，也就是第三次挥手，然后客户端收到服务器的结束包后发送响应包，也就是第四次挥手。

再总结一下TCP三次握手到底要达到什么目的，

一个是：客户端确定自己发送的包服务器能够接收到；服务器端确定自己发送的包客户端能够接收到。

第二个：客户端把自己的同步序号发给了服务器，同时服务器也收到了。这样客户端接下来发送的包的序号就是从这个seq开始，同理，服务器也需要把自己的seq发给客户端；**这样两边就都知道对方接下来的发包序号了**。。（这就防止丢包嘛，对吧）达到同步的效果。

下面这个只是一个表象，本质还是我上面说的必须通过最少三次握手才能保证双方都拿到了对方的seq，因为tcp可靠本质上就是用这个包的序列seq来保证。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215173942.png)



### 四次挥手

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215175154.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215170722.png)

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211215175403.png)

第一次挥手：FIN=1,**seq=u**，客户端告诉服务器端我的数据已经发完了，我这边要释放连接了。此时，客户端进入FIN-WAIT-1

第二次挥手：那服务器端收到客户端发的终止数据包，服务器肯定得回一个响应包啊，所以发ACK=1,seq=v,**ack = u+1**;这样客户端收到后就知道我发的结束消息服务器已经收到了。此时服务器处于CLOSE-WAIT，也就是关闭等待，服务器等待什么呢？其实在等待应用层把数据发完，然后发送命令给操作系统网络接口，然后执行第三四次挥手。。。

然后服务器可能还需要给客户端传输一些数据。。。传完之后：

第三次挥手：服务器也发送终止数据包了，所以发FIN=1,ACK=1,seq=w,**ack=u+1**,可以看到这里的ack还是u+1,因为从第二次挥手，后面一直是服务器端再发送数据包，所以**第三次挥手的ack还是u+1**，可能本质上还是对第一次挥手的回应。。但是这些数据包的seq肯定在不断加1。。**加入此时seq加到了w**

第四次挥手：客户端收到第三次挥手中服务器发来的FIN包之后，会立马发出响应包，ACK=1,**ack=w+1,序列号则是第一次挥手的序列号加1，seq=u+1,**然后客户端进入Time-wait状态。。注意此时TCP还没释放，必须等待2*MSL后，然后客户端撤销相应的TCB后，才进入CLOSE状态。。

而服务器一收到客户端的响应报文，立即撤销TCB，进入CLOSE状态。所以服务器会比客户端先进入CLOSE。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211216104914.png)



### TCP长连接

在tcp建立连接之后，会保持这种连接状态，但不是一直保持，当一定时间后，服务器会向客户端发送探测报文段：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211216164641.png)



总结一下：SYN不能携带数据，但需要消耗一个seq; ACK如果不携带数据则不消耗seq，如果携带则消耗一个seq；FIN即是不携带数据也要消耗一个seq；

参考：

tcp三次握手、四次挥手出现异常：https://bbs.huaweicloud.com/blogs/detail/293731

