Raft中如果Leader正常运行，Raft不太会出现问题，因为Leader正常运行，并且有过半的服务器，那Leader只需要告诉Follows，Log该是什么样子，**Raft要求Follows必须同意并接收Leader的Log（只要Follows还能处理，他们就会全盘接收在AppendEntries中发送给它们的内容，就是把op操作加到log数组中），**所有这样其实很难出错。

我们再来想想，一个旧Leader故障了，而且此时不同副本上的log可能已经互不相同了，那为了恢复系统的一致性，新Leader该怎么做？

还是得关注log，想一想，leader发生故障之后，log会怎么样？

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20220427112918.png)

比如左边，这种情况怎么发生的？

在第二个槽位，S1没有收到任期号为3的op，这其实有三种原因：

- 发送给S1的消息丢了
- S1当时关机了
- S3是leader，但是他把AppendEntries发送给S2之后，然后在发送AppendEntries给S1之前就挂了

以上其实就是一种不同节点之间有不同Log的情况，假设现任leader S3故障了，然后发生新的选举，然后新leader需要知道：

- 新leader需要认识到，槽位2的请求可能已经commit了，从而不能丢弃（对于已经commit的客户端请求，leader不能丢弃）
- 新leader还需要保证S1在槽位2记录与其他节点完全一样的请求

----

再来看看右边，怎么发生的？

槽位10、11还是一样填的都是任期号为3的消息，新leader是S2，它的任期号是4，S2这个leader接收到了客户端的请求，然后自己本地在槽位12增加一条日志，但是之后就挂了，然后重新选举后S3成了新leader，任期号变成5，自己本地在槽位12增加一条日志，但是之后也挂了。



所以，Raft要能处理这样情况。但是还是得记住对于只要有已经commit可能性的操作，新leader都不能删除，所以看上图，槽位10，三个Server都有日志，所以可能已经commit，槽位11也是，过半server已经有日志，不能丢弃。**槽位12的两个log，因为没有过半服务器有对应日志，所以肯定没有commit，所以Raft可以丢弃它们，这里至少要求丢一个，因为我们目的还是保持多副本之间log的一致性**。

还需要注意：对于槽位10和11的log，虽然都超过一半的server有，但是并不能保证对应的请求被执行了，因为可能leader把消息发给其他server之后就挂了，这都没有来及的收到过半server的响应消息，leader自然不会commit，也就不会执行这个请求。所以槽位10和11的请求可能没有执行。所以如果Raft知道它们一定没执行，那丢弃槽位10和11的日志也是合法的。**但是，只要存在commit的可能性，Raft就不能丢弃这些日志。因为客户端那边可能已经收到了已经执行成功的响应消息。**