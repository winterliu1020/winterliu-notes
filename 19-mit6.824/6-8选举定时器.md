想想leader是怎么阻止其他节点成为新的leader的呢？

我们知道发生选举的唯一条件是有节点选举定时器耗尽，然后这个节点会向其他N-1个节点发起投票，当赢得了过半server的同意选票就会成为新的leader。而怎么去阻止别的节点成为新的leader呢？其实就是不断的发送心跳或者AppendEntries消息，这样其他节点收到消息之后就会重置选举定时器，避免耗尽重新选举。

还有分割选票问题，比如有3个机器，三个节点假设同时选举定时器耗尽，然后他们3同时RequestVote，但是每个人都是自己投给自己，所以每个机器都只有一票。那他们都不能变成leader，**然后所有的选举定时器重新开始计时，然后等同一段时间所有节点又投票给自己**。

所以Raft不能完全避免分割选票，但是Raft可以把这个选举定时器时间设置随机，并且设置的定时器时间得大于一次心跳的时间间隔。。然后考虑到心跳的丢包，所以定时器时间下限可以设置成几倍的心跳间隔，上限也得考虑，因为太长了，会影响系统尽快重新恢复。。。

因为得到计时器耗尽，才会重新选举，所以计时器太长，这段时间都没有新的leader，客户端请求会被丢弃。所以这里上限要考虑系统的恢复时间。

还要注意不同节点的定时器时间差得足够长，让第一个开始选举的节点有足够的时间完成一轮选举。所以至少要大于发送一条RPC所需要的往返时间。（**在lab2中要考虑**）



总的来说就是：每台机器都应该在机器启动之后每次都随机一个定时器时间，并且让两台机器之间的定时器时间大一些，足够发一次RPC往返，来避免分割选票的情况。