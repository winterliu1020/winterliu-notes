![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207104027.png)

首先你想一想，一个类是怎么被创建的？是不是通过new指令呢？对的，那当new指令后面接一个类名会发生什么呢？我们可以想象一下，Object object = new Object(); 虚拟机碰到new的时候，从下面.class文件中可以看到，虚拟机会先去**检查new指令后面接的参数是否能在常量池中定位到这个类的符号引用**，也就是这里的#3，这里的#3在常量池表中可以看到可以定位到java/lang/Object这个类。

> 通过这里我们又可以知道.class文件中常量池表存的到底是些什么了，哈哈哈，不就包括Object这个类的完整路径嘛，当然还有其它所有的类。那常量池表中还有其它东西嘛？当然你在类中（也就是类的属性）定义的final类型的常量，比如下面的a，以及这a对应的值也会在常量池表中。

上面才说了new的时候会检查是否能在常量池表中定位到这个类，当可以定位到的时候，然后需要检查这个类是否已经加载、解析、初始化过，如果还没有，那当然需要马上开始类加载了。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207102642.png)

这里就不细说类加载的详细过程了，假设类已经加载进来了，那你要创建一个对象，下一步就是给对象分配内存了，java虚拟机中说一个类被加载到jvm后，这个类对应的对象的大小就知道了，从下图中可以看到一个对象的大小由哪些部分组成，其中base是由当前类从父类那里继承来的属性的大小，然后加上当前类非静态属性的大小（我理解的大小应该是这个属性对应的整个类的大小，比如一个属性是Animal类，那加这个属性应该是加上这个Animal类的大小），当然这里还说得加内存对齐导致的padding。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207110344.png)

现在我们知道要给当前对象分配具体多大的内存了，然后到堆里面去划分出这么大的内存空间，怎么划分有两种方式：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207111111.png)

在Java中对象内存分配是很频繁的一个操作，那jvm怎么保证并发呢？这里当然有并发问题，因为其实就是一块空间，然后多个线程同时去创建对象，创建对象当然得向这一块共用的工具请求分割一点内存给自己，这就会带来并发问题。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207111637.png)

一般是用以上两种方式来解决，其实用CAS还是比较高效的，因为不管是完整的一个内存空间还是大小不同的各个内存块，如果用CAS，只需要用一种方式记录当前内存状态，比如如果是指针碰撞，那当然是利用分界指针来记录状态了，如果是空闲列表，可以用对这个列表hash的方式记录下当前空闲列表的状态，用CAS都是需要先记录状态，然后执行分配内存的操作，如果发现状态没变，说明当前没有其它线程去分配内存，也就是说明当前线程可以执行分配内存操作。如果状态变化了，说明这个共享的大内存块已经被别的线程执行了分割操作，那你当前线程用的状态就不是最新的了，所以需要**重新CAS**。

当然可以用本地内存的方式，也就是这里所说的先给每一个线程在Eden区分配一个小的内存块，然后这个线程分配对象内存的时候直接用Eden区的这个小内存块即可，如果TLAB不够了，再用CAS给这个线程的TLAB分配新的内存。

### 初始化零值（零值指的是字段类型对应的默认值）

现在我们对象内存分配完了，然后jvm得给这个对象的属性分配零值（不包括对象头），她妈的我之前以为啥零值啊，原来就是各个类型的默认值，比如有一个属性是int类型，那初始化零值就是给这个属性赋值为0，boolean就赋值为false。。为什么要初始化零值呢？还不是jvm为了我们好啊，你想想你有时候直接用boolean属性的默认false，有时候用int数组的默认都是0，这都是jvm在这步帮我们做的啊，我们后面就不需要再去赋值。

<img src="https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207113611.png" style="zoom:50%;" />

### 设置对象头

比如上面是一个对象的简化描述，经过初始化零值我们才给中间的属性部分赋予了默认值，整个对象头还没有赋值呢。。。那你想想Java对象头里面有什么呢。。。一个对象，本质上就是一片空间而已，那我们在Java 代码中用对象找到对应的类，怎么找到的呢？就是通过对象头里面存的东西啊，所以对象头里面必定存了这个对象对应的是哪个类、以及这对象对应的类的元数据信息（我觉得这里就是保存了class对象的位置），还有Java中特有的在对象头中放置GC分代年龄，是否设置偏向锁啥的。。。

### 执行init方法

还是看这张图，设置完对象头之后，从虚拟机的角度看，一个对象其实已经创建好了，但是从我们Java程序员来看，我们利用构造函数传递的初始值还没赋值给这个对象呢，所以new指令后面接着的立马是 init 函数，把我们传递的参数给对象初始化，也就是对给这个对象开辟的这片空间的第二个块，即实例数据进行构造函数赋值，**这才产生了一个对象。**

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207102642.png)



### 再来看看Java对象头中有什么呢

比如之前聊并发synchronized中用到的对象头中的mark word，这是第一块数据（存储对象自身的运行时数据，比如GC分代年龄、哈希、偏向锁之类的东西），第二块数据是什么呢？你想想，一个对象怎么找到它对应的类的元数据呢？其实也是在对象头中放了一个东西，利用这个东西才能够找到对应类的元数据，这部分叫做**类型指针**（我觉得就是存的执行这个类在堆中对应的那个class对象的地址。。。）

到此，你才知道一个对象怎么产生的，这个对象内存空间来源于哪里，该给他分配多少空间，给它分配了空间后，jvm又需要怎么对这个对象空间进行划分，然后再对各个子空间进行赋值。你得明白这个对象空间由哪些部分组成，各个部分放了对象的哪些东西。

### 创建对象是为了访问对象

访问对象又包括句柄访问和直接指针访问。。。













