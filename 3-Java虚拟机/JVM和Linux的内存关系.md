### JVM内存和操作系统内存的关系

首先看一下Linux与进程内存模型：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20210402113134.png)

硬件上：物理内存不够时，Linux会把一部分不用的数据先放到swap磁盘上，当需要用到swap磁盘上的数据时，必须先将其换回到内存中。

Linux系统上：除了引导系统的BIN区，其他分为内核内存（内核态）和用户内存（用户态）。

内核内存：是Linux自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。

用户内存：提供给各个进程主要空间，Linux会**给每个进程提供相同的虚拟内存空间**；这使得各个进程之间互相独立、互不干扰。**采用虚拟内存技术**：给每一个进程一定的虚拟内存空间，只有当虚拟内存实际被使用时，才分配物理内存。

jvm是以一个进程的方式运行在Linux系统上，jvm本质上就是一个进程，因此其内存空间（也称为运行时数据区）也有进程的一般特点。而jvm又不是一个普通的进程，它在内存空间上有一些新特点：

1.jvm将许多本来属于操作系统管理范畴的东西移植到了jvm内部（比如对象内存的分配），目的在于**减少系统调用**的次数。

2.Java NIO，目的在于**减少用于读写IO的系统调用的开销**。

jvm进程和普通进程内存模型比较：

从下可以看到，操作系统会给每一个进程分配以下内存，包括在内核中的内核内存，然后在用户空间中的代码区、数据区、堆区、栈区、还有一块未使用的区域；转移到jvm进程来看，因为jvm也是由C++写的一个程序，这个程序以一个进程的形式运行在操作系统，所以和普通进程一样，写jvm的这些c++代码放在jvm代码区，然后jvm这个程序运行产生的数据放到jvm数据区。

然后是**普通进程中的堆区，映射到jvm进程就是jvm中的永久代和新生代和老年代**，其中永久代放的是JVM中跑的Java程序代码和静态资源；而真正注意的是**新生代和老年代，我们看JVM中的堆对应的就是这块空间**，也就是说这块空间会放Java程序中产生的所有对象；

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20210402114852.png)

注意这里的**jvm代码区和jvm数据区**指的是jvm自身的，不是Java程序的。普通进程中的栈区空间，在jvm中一般仅仅用作线程栈。

永久代对于操作系统来说，是堆的一部分；而对于Java程序来说，这是容纳程序本身以及静态资源的空间，使得jvm能够解释执行Java程序。

其次是**新生代和老年代，这才是Java程序真正使用的堆空间**，用于Java程序中内存对象的存储；但是jvm中的堆和普通进程中的堆在管理方式上有本质的区别。

**普通进程在给内存对象分配/释放空间：**

比如C++执行new操作时，会触发一次分配内存空间的系统调用，由操作系统的线程根据对象的大小分配好空间后返回；同时，释放对象，比如delete时，也会触发系统调用通知操作系统对象所占用的空间可以回收了。

**jvm进程给内存对象分配/释放空间（重点）：**

JVM对内存的使用和一般进程不同。JVM向操作系统申请一整段内存区域（具体大小可以在JVM参数调节）作为Java程序的堆（分为新生代和老年代）；当Java程序申请内存空间，比如执行new操作，JVM将在这段空间中按所需大小分配给Java程序，并且Java程序不负责通知JVM何时可以释放这 个对象的空间，垃圾对象内存空间的回收由JVM进行。

**jvm进程相比较普通进程在管理内存上的好处：**

1. 减少系统调用次数，jvm在给Java程序分配内存空间时不需操作系统干预，只在整个Java堆大小变化时需要向操作系统申请内存或通知回收，普通进程每次操作内存都需要系统调用参与。
2. 减少内存泄露，普通进程需要自己手动申请、释放，而jvm可以统一管理内存的释放和回收。

### 对于Java NIO

java对NIO抽象为channel，channel又可以分为FileChannel(磁盘io)和SocketChannel(网络io)。

NIO抽象为channel是面向缓冲区的、非阻塞IO。channel只负责传输，数据由Buffer负责存储。Buffer又有三种，**HeapByteBuffer会分配在jvm堆内**，所以受jvm堆大小的限制，创建**速度快，但是读写慢，底层实际是一个字节数组**。**DirectByteBuffer会分配在jvm堆外，但是在jvm这个进程的堆内**，不受jvm堆大小的限制，**创建速度慢，读写快**。还有一种是mmp（memory mapping 内存映射）。

尽管 `DirectByteBuffer` 是堆外，但是当堆外内存占用达到 `-XX:MaxDirectMemorySize` 的时候，也会触发 FullGC ，如果堆外没有办法回收内存，就会抛出 OOM。

#### 堆外内存如何回收呢？

`DirectByteBuffer`类有一个成员变量`private final Cleaner cleaner`,当触发FullGC的时候，cleaner没有gc root可达，导致cleaner会被回收，回收的时候会触发Clean.clean方法的调用，clean方法中就会调用Unsafe.freeMemory来释放堆外内存。

### 内存映射

一般的物理磁盘和应用程序数据交换流程：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20210402154151.png)

当应用程序读文件的时候，数据需要从先从磁盘读取到内核空间(第一次读写，没有 page cache 缓存数据)，在从内核空间 copy 到用户空间，这样应用程序才能使用读到的数据。当一个文件的全部数据都在内核的 Page Cache 上时，就不用再从磁盘读了，直接从内核空间 copy 到用户空间去了。

应用程序对一个文件写数据时，先将要写的数据 copy 到内核 的 page cache，然后调用 `fsync` 将数据从内核落盘到文件上（只要调用返回成功，数据就不会丢失）。或者不调用 `fsync` 落盘，应用程序的数据只要写入到 内核的 pagecache 上，写入操作就算完成了，数据的落盘交由 `内核` 的 Io 调度程序在适当的时机来落盘（突然断电会丢数据，MySQL 这样的程序都是自己维护数据的落盘的）。

我们可以看到数据的读写总会经过从用户空间与内核空间的 copy ,如果能把这个 copy 去掉，效率就会高很多，这就是 mmap （内存映射）。将用户空间和内核空间的内存指向同一块物理内存。`内存映射` 英文为 `Memory Mapping` ,缩写 `mmap`。对应系统调用 [mmap](https://man7.org/linux/man-pages/man2/mmap.2.html)

这样在用户空间读写数据，实际操作的也是内核空间的，减少了数据的 copy 。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/winterliu-notes/JVM/20210402154857.png)

怎么实现的呢，简单来说就是 linux 中进程的地址是虚拟地址，cpu 会将虚拟地址映射到物理内存的物理地址上。mmap 实际是将用户进程的某块虚拟地址与内核空间的某块虚拟地址映射到同一块物理内存上，已达到减少数据的 copy 。

用户程序调用系统调用 `mmap` 之后的数据的读写都不需要调用系统调用 `read` 和 `write` 了。

### jvm内存分配问题

SWAP和GC同时发生会导致GC时间很长，JVM严重卡顿，极端的情况下会导致服务崩溃。原因如下：JVM进行GC时，需要对相应堆分区的已用 内存进行遍历；假如GC的时候，有堆的一部分内容被交换到SWAP中，遍历到这部分的时候就需要将其交换回内存，同时由于内存空间不足，就需要把内存中堆 的另外一部分换到SWAP中去；于是在遍历堆分区的过程中，(极端情况下)会把整个堆分区轮流往SWAP写一遍。Linux对SWAP的回收是滞后的，我 们就会看到大量SWAP占用。上述问题，可以通过减少堆大小，或者增加物理内存解决。



