## 1. 垃圾收集的一些概念

想一下为什么要垃圾回收，当然对象不能创建后就一直存在内存，当然得对一些死亡对象进行垃圾回收，那想想你怎么去判断一个对象已经死亡呢？

而Java中的引用又有强、软、弱、虚引用四种，四种引用在面对GC时又有不同的回收级别，比如虚引用在没太使用的时候GC就会将其回收，还不会等到这个对象完全死亡呢。。。根据引用等级对应不同的GC紧急程度。

还有常量呢？你怎么判断常量该不该回收呢？常量又不是对象。。还有类，你怎么判断类是无用的类呢？

以上是收集对象的问题，再想想垃圾收集算法的问题？有哪些算法呢，各自特点？

还有你有没有想过HotSpot在堆里面为啥要分新生代、老年代呢。。。其实大概你可以知道是为了更快的垃圾回收，但是怎么利用这两个区间来达到更快的垃圾回收呢？

还有常见垃圾收集器？知道哪些？

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207174900.png)

首先想一个问题：**我们为什么要熟悉这个垃圾收集的过程？**

这是虚拟机帮我们自动做的啊，但是当你在你的系统中遇到内存他妈的泄漏了，你怎么去定位呢？泄漏了肯定是一直在给对象分配内存，而没有及时对死亡对象进行内存回收。。。对吧，而且如果你的系统的瓶颈在于垃圾回收，也就是说你的系统中对象越来越多了，不用的对象却不会被回收，那你就要监控这个垃圾收集的过程，调整一下参数（比如堆的大小、对象最高的分代年龄。。）。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211207175639.png)

### 对象首先在Eden分配

经过对新生代的一次GC之后，Eden区中如果没被回收的，则进入to区域（Eden区中对象年龄本来是0，进入Eden区后变成1），同时from区域所有对象也经历这次GC，from区域没被回收的对象，年龄会加1，然后放到to区域。然后from指针指向to区域，to指针指向from区域。

**经过默认年龄阈值15还没被回收，则进入老年代**；大对象直接进入老年代，什么意思呢？？就是当你对新生代GC的时候，我们不是对Eden和from所有对象进行GC吗，然后把这些没有被回收的对象放到to区域，**如果to区域放不下，这剩下的对象直接放到老年代。**

当新的对象不断在Eden区分配。。。然后当给某个对象在Eden区分配内存的时候，发现Eden区剩余内存不够了，这时候jvm会执行一次Minor GC。那原先在Eden区的对象就会被转移到from区域，如果from区域放不下原先的那个对象，怎么办呢？jvm会通过**分配担保机制**直接把原来放不下的那个对象**直接从Eden区转移到老年代。**当然如果后续还进行对象分配，还是先在Eden。

### 大对象直接进入老年代

需要连续空间的数组、字符串，避免由于分配担保机制导致大块内存复制，所以还不如直接放到老年代。



### 其它

Partial GC, Full GC

GC主要是对堆进行，那堆中分为新生代、老年代，对吧。。所以把**对堆的收集称为Partial GC**，包括只对新生代（Minor GC），只对老年代（Major GC）,整个新生代和部分老年代（Mixed GC）;还有**对整个堆和方法区的收集，叫Full GC.**

**空间分配担保**：这是什么呢？想一下前面进行Minor GC时，如果经历GC后新生代中还没被回收的对象，如果它放不下或者年龄已经到了15，那这些对象不是要放到老年代嘛。。。如果极端情况下所有新生代的对象经历这个Minor GC都需要放到老年代。。。如果老年代也放不下，那不完了吗。。所以进行Minor GC之前得做一个检查（检查老年代可用的连续空间是否大于新生代所有对象的空间，大于那肯定没问题啊，如果小于呢？那再看看老年代可用空间是不是大于历代从新生代转到老年代所有对象的大小，如果老年代现在可用空间大于这个大小，那说明很大程度上也没问题，所以让它去执行Minor GC就行了。。。），**如果检查老年代空间不太够呢。。。那就会执行Full GC**。清除老年代中一些死的对象，空出空间。



## 2. 对象已经死亡？

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211208104056.png)

要对堆回收，就得看堆中对象是不是已经死亡，那你他妈怎么知道对象已经死了？？从你的现有认知去想，什么时候你会觉得一个对象死了呢？而死又是什么意思呢？那对象存在又意味着什么呢？我觉得存在意味着这个对象能在内存中与其它东西产生关联，那啥叫产生关联呢？我觉得就是这个对象指向别人，或者别人指向这个对象咯。。。

所以再说对象死了，也就很清楚了，就是这个对象没有和内存中其它东西有任何关联了，也就是说这个对象不指向其它人，其他人也不指向这个对象。那你怎么知道这种关联呢？那肯定是基于记录咯，你指向别人或者别人指向你，把这种关联记录下来。。。所以有叫**引用计数法**（无法解决循环引用的问题，所以不太用），当然你不记录，你用**可达性分析**也没问题，从上到下去分析这个对象有没有和其他人产生关联。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211208110258.png)

## 再谈引用

刚看了一下强、软、弱、虚四种引用，发现还是挺简单的，想一下，四个引用强度依次降低，引用强弱和GC有关系，**强引用**，GC的时候宁愿OOM都不对强引用对象进行回收。**软引用**，用的还是比较多的，主要为了加速jvm对垃圾的回收，当GC的时候发现内存不够的时候才会对软引用对象进行回收。**弱引用**，当GC的时候，扫描到弱引用，不管当前内存空间够不够，都把弱引用对象进行回收。

然后软引用和弱引用都可以和一个引用队列关联，当这两类的引用对象被回收后，这两类引用会放到引用队列中。

还有最后一个虚引用，主要用于监控垃圾被回收这个事件，因为它必须和一个引用队列关联，当这个虚引用对象被回收之前，这个虚引用会被放到引用队列中，这样你通过监控这个引用队列就可以知道这个引用指向的对象即将被回收，从而**在回收之前你可以采取一些措施**。虚引用主要是这个作用。

## 不可达对象并非非死不可

发现对象不可达之后，只是会对这个对象进行第一次标记，当标记之后会再进行一次判断，判断这个对象的finalize方法是否被覆盖，如果没有覆盖，或者这个对象的finalize方法（相对于一个一次性的免死金牌）已经她妈的调用了，那你这个对象直接宣判死亡了。。当然如果这个对象有finalize方法而且还没用，则进入第二次可达性检验，如果还是发现不可达，那宣判死亡。

## 对其他的回收

主要是对堆中对象的回收，当然常量池中无用常量也得回收，比如字符串常量池中那些没有被字符串引用指向的字符串，还有方法区中无用的类，其实就是这些.class文件吧。。

你想想一个类什么时候会被说可以回收呢？以我的思考，类会被回收，说明这个类所有的对象没了。。加载这个类的ClassLoader也他妈没了。。而且通过类加载器加载的对应这个类的class对象都尼玛没了。。那这个类就没有存在的必要了。。但是这里也只是说**可以**对这个类进行回收。。

## 3. 垃圾收集算法

标记-清除，标记-复制，标记-整理；

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211208162929.png)

