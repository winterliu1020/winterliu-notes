方法区、堆区、栈（虚拟机栈），这是Java虚拟机的规范，不管你是哪个版本的虚拟机，你都得符合这些规范去设计，在1.8以前，hotspot虚拟机对应这三个的实现分别是：永久代、新生代和老年代、栈；而1.8时，hotspot取消了永久代这个概念，注意方法区这个规范还是在的，因为这是设计虚拟机的规范，取消永久代，用元空间来替代，所以元空间存储了方法区规范中应该存储的数据。

之前永久代是放在运行时数据区，而现在元空间放到了本地内存中，**为什么要取消永久代用元空间替代呢**？

为了避免OOM。首先我们从JVM和Linux的内存关系可以知道，如果在1.8以前，永久代（方法区）和新生代老年代（堆区）在物理内存上是连续的，他们都是放在运行时数据区，且永久代初始配置的空间大小有限，所以当程序中加载的.class文件过多时，这个永久代就会OOM。而当1.8取消永久代，以元空间的形式放到本地内存，这样和堆区不是物理内存直接相连，理论上本地内存有多大 元空间就有多大。所以不会OOM。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206115555.png)



再来看看方法区和静态变量的关系：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206153656.png)

我们再来看看虚拟机栈，Java程序是从Main方法进入的，然后执行这个Main方法，当中会产生一些局部变量（八大基本数据类型和**对象的引用**），当然执行这个方法中一条指令的时候可能用到**操作数栈**，当然这个Main方法可能还会调用其他方法。

JVM将每个方法封装成虚拟机栈中的一个栈帧，每一个栈帧包括上面说的：局部变量表（**存放在编译的时候就可以知道的各种基本数据类型和对象的引用**（因为对象实例的长度是可变的，但是引用的长度是固定的，所以局部变量表中放的是对象的引用，对象实例放在堆区））、操作数栈、如果再调用另外一个方法就又在虚拟机栈中放入一个栈帧，当然还有方法的出口（从出口出去之后当前这个栈帧就结束了）。

对上面说的**对象的引用有没有好奇呢**？我们知道JVM只是设置了一个规范说对象的引用需要指向对象实例，但是没有规定以何种方式指向实例，常见**JVM的实现中有指向一个句柄（常用、稳定），或者直接指向实例数据**，所以局部变量表中存储的对象的引用要么就是一个对象的句柄地址，要么就是这个对象实例的开始地址，或者说存储的是其他的东西也行，**只要是能够访问到这个对象即可。**

## 来看看堆

Java中几乎所有对象都是分配在堆中的。我觉得以下优化是为了提高访问对象实例的速度，比如通过逃逸分析技术发现这个对象没有被方法外的其他地方使用，那么这个实例对象其实和本地变量是一样的，所以为了提高访问速度，我和不把这个实例对象直接通过转换，放在栈内存上呢。。所以并不是所有对象都放在堆。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206164444.png)

对于堆这块区域，你需要知道几乎所有的对象都放在这里，而Java中对象的回收又是又JVM来完成的，而回收的主要目标就是对象，所以这块区域也叫GC堆。

从前面看的Linux操作系统下普通进程和JVM进程在内存分布上的映射关系可以知道，普通进程的堆空间映射到JVM进程中的：永久代、新生代、老年代，而新生代和老年代就是JVM中的堆区，永久代在1.8之后换成元空间放到了本地内存，而新生代和老年代细看可以分为Eden区、survivor from、survivor to区。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206165640.png)

想一想为什么要分这么多区呢？为了更快的GC，或者说更快的分配对象的内存。

堆区最容易出现OOM，包括执行很多次GC但是回收不了多少内存、或者分配对象的时候堆里面根据没有足够内存了，这两种情况都是OOM。

## 再来看看方法区

我们知道方法区是针对类而言的，你得从类的这个维度来看方法区，你就知道方法区存的是哪些东西。比如它存了.class文件，加载进来的这些**.class文件**都是放在方法区；当然还有**静态变量**，这也是属于类的东西啊，对吧，所以静态变量也是放方法区，但是需要注意的是，其实这里只放了静态变量的引用，如果这个静态变量指向一个new出来的实例对象，这个实例对象还得放到堆中；当然还有**类信息、常量**。但是我们知道1.8之后取消了方法区（其实方法区是一种逻辑概念，所以并没有取消方法区，而是取消了永久代，用元空间替代永久代，此时的元空间就是1.8之后的方法区）。

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206172503.png)



对于字符串常量池、运行时常量池在各个版本中放在哪里，其实还不是很清楚，接着往下看：

## 字符串常量池、运行时常量池

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206175920.png)

看看各版本运行时常量池、字符串常量池的关系：

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206180029.png)

也就是说1.7之前运行时常量池是逻辑包含字符串常量池的，都在方法区，**1.7的时候单独把字符串常量池放到堆**，1.8又把运行时常量池剩余的东西放到元空间。

### 直接内存

![](https://winterliublog.oss-cn-beijing.aliyuncs.com/notes/20211206180748.png)